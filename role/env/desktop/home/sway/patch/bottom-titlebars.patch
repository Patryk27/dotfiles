diff --git a/sway/desktop/render.c b/sway/desktop/render.c
index 17fc8f6f..bcaad1ab 100644
--- a/sway/desktop/render.c
+++ b/sway/desktop/render.c
@@ -750,8 +750,10 @@ static void render_containers_linear(struct sway_output *output,
 			}
 
 			if (state->border == B_NORMAL) {
+				int y = state->y + state->height - container_titlebar_height();
+
 				render_titlebar(output, damage, child, floor(state->x),
-						floor(state->y), state->width, colors,
+						floor(y), state->width, colors,
 						title_texture, marks_texture);
 			} else if (state->border == B_PIXEL) {
 				render_top_border(output, damage, child, colors);
@@ -806,13 +808,14 @@ static void render_containers_tabbed(struct sway_output *output,
 		}
 
 		int x = floor(cstate->x + tab_width * i);
+		int y = parent->box.y + parent->box.height - container_titlebar_height();
 
 		// Make last tab use the remaining width of the parent
 		if (i == parent->children->length - 1) {
 			tab_width = parent->box.width - tab_width * i;
 		}
 
-		render_titlebar(output, damage, child, x, parent->box.y, tab_width,
+		render_titlebar(output, damage, child, x, y, tab_width,
 				colors, title_texture, marks_texture);
 
 		if (child == current) {
@@ -870,7 +873,8 @@ static void render_containers_stacked(struct sway_output *output,
 			marks_texture = child->marks_unfocused;
 		}
 
-		int y = parent->box.y + titlebar_height * i;
+		int y = parent->box.height - titlebar_height * (parent->children->length - i) - (child->pending.border_thickness * child->pending.border_bottom);
+
 		render_titlebar(output, damage, child, parent->box.x, y,
 				parent->box.width, colors, title_texture, marks_texture);
 
@@ -970,8 +974,10 @@ static void render_floating_container(struct sway_output *soutput,
 		}
 
 		if (con->current.border == B_NORMAL) {
+			int y = con->current.y + con->current.height - container_titlebar_height();
+
 			render_titlebar(soutput, damage, con, floor(con->current.x),
-					floor(con->current.y), con->current.width, colors,
+					floor(y), con->current.width, colors,
 					title_texture, marks_texture);
 		} else if (con->current.border == B_PIXEL) {
 			render_top_border(soutput, damage, con, colors);
diff --git a/sway/tree/container.c b/sway/tree/container.c
index 943d3d53..3c731c6d 100644
--- a/sway/tree/container.c
+++ b/sway/tree/container.c
@@ -901,14 +901,13 @@ void container_set_geometry_from_content(struct sway_container *con) {
 
 	if (con->pending.border != B_CSD && !con->pending.fullscreen_mode) {
 		border_width = con->pending.border_thickness * (con->pending.border != B_NONE);
-		top = con->pending.border == B_NORMAL ?
-			container_titlebar_height() : border_width;
+		top = border_width;
 	}
 
 	con->pending.x = con->pending.content_x - border_width;
 	con->pending.y = con->pending.content_y - top;
 	con->pending.width = con->pending.content_width + border_width * 2;
-	con->pending.height = top + con->pending.content_height + border_width;
+	con->pending.height = top + con->pending.content_height + container_titlebar_height();
 	node_set_dirty(&con->node);
 }
 
diff --git a/sway/tree/view.c b/sway/tree/view.c
index bd53a5c8..72a61135 100644
--- a/sway/tree/view.c
+++ b/sway/tree/view.c
@@ -258,9 +258,9 @@ void view_autoconfigure(struct sway_view *view) {
 		return;
 	}
 
-	con->pending.border_top = con->pending.border_bottom = true;
+	con->pending.border_top = true;
+	con->pending.border_bottom = false;
 	con->pending.border_left = con->pending.border_right = true;
-	double y_offset = 0;
 
 	if (!container_is_floating_or_child(con) && ws) {
 		if (config->hide_edge_borders == E_BOTH
@@ -274,7 +274,7 @@ void view_autoconfigure(struct sway_view *view) {
 				|| config->hide_edge_borders == E_HORIZONTAL) {
 			con->pending.border_top = con->pending.y != ws->y;
 			int bottom_y = con->pending.y + con->pending.height;
-			con->pending.border_bottom = bottom_y != ws->y + ws->height;
+			con->pending.border_bottom &= bottom_y != ws->y + ws->height;
 		}
 
 		bool smart = config->hide_edge_borders_smart == ESMART_ON ||
@@ -299,10 +299,8 @@ void view_autoconfigure(struct sway_view *view) {
 		if (show_titlebar) {
 			enum sway_container_layout layout = container_parent_layout(con);
 			if (layout == L_TABBED) {
-				y_offset = container_titlebar_height();
 				con->pending.border_top = false;
 			} else if (layout == L_STACKED) {
-				y_offset = container_titlebar_height() * siblings->length;
 				con->pending.border_top = false;
 			}
 		}
@@ -314,17 +312,17 @@ void view_autoconfigure(struct sway_view *view) {
 	case B_CSD:
 	case B_NONE:
 		x = con->pending.x;
-		y = con->pending.y + y_offset;
+		y = con->pending.y;
 		width = con->pending.width;
-		height = con->pending.height - y_offset;
+		height = con->pending.height;
 		break;
 	case B_PIXEL:
 		x = con->pending.x + con->pending.border_thickness * con->pending.border_left;
-		y = con->pending.y + con->pending.border_thickness * con->pending.border_top + y_offset;
+		y = con->pending.y + con->pending.border_thickness * con->pending.border_top;
 		width = con->pending.width
 			- con->pending.border_thickness * con->pending.border_left
 			- con->pending.border_thickness * con->pending.border_right;
-		height = con->pending.height - y_offset
+		height = con->pending.height
 			- con->pending.border_thickness * con->pending.border_top
 			- con->pending.border_thickness * con->pending.border_bottom;
 		break;
@@ -334,15 +332,9 @@ void view_autoconfigure(struct sway_view *view) {
 		width = con->pending.width
 			- con->pending.border_thickness * con->pending.border_left
 			- con->pending.border_thickness * con->pending.border_right;
-		if (y_offset) {
-			y = con->pending.y + y_offset;
-			height = con->pending.height - y_offset
-				- con->pending.border_thickness * con->pending.border_bottom;
-		} else {
-			y = con->pending.y + container_titlebar_height();
-			height = con->pending.height - container_titlebar_height()
-				- con->pending.border_thickness * con->pending.border_bottom;
-		}
+		y = con->pending.y;
+		height = con->pending.height - container_titlebar_height()
+			- con->pending.border_thickness * con->pending.border_bottom;
 		break;
 	}
 
